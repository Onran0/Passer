package com.github.onran0.passer.io;

import com.github.onran0.passer.core.PasswordInfo;
import com.github.onran0.passer.core.Passes;
import com.github.onran0.passer.crypto.*;
import com.github.onran0.passer.security.RuntimeSecurity;
import com.github.onran0.passer.security.SecuredCharArray;

import static com.github.onran0.passer.core.PasserCore.*;

import java.io.*;
import java.security.GeneralSecurityException;

public final class PASSERWriter {

    private static final int DEFAULT_STORE_VERSION = V_2;

    private static final int KDF_ITERATIONS = 2_000_000;
    private static final int CIPHER_KEY_SIZE = 256;

    private final int version;
    private final DataOutputStream out;
    private final ISymmetricCipher cipher;
    private final IKDF kdf;

    public PASSERWriter(
            final OutputStream out,
            final String cipherAlgorithm,
            final String kdfAlgorithm
    ) {
        this(out, cipherAlgorithm, kdfAlgorithm, DEFAULT_STORE_VERSION);
    }

    public PASSERWriter(
            final OutputStream out,
            final String cipherAlgorithm,
            final String kdfAlgorithm,
            final int version
    ) {
        this.out = new DataOutputStream(out);
        this.cipher = CryptoFactory.getSymmetricCipherInstance(cipherAlgorithm);
        this.kdf = CryptoFactory.getKDFInstance(kdfAlgorithm);
        this.version = version;
    }

    public void write(final Passes passes, final SecuredCharArray masterPassword) throws IOException, GeneralSecurityException {
        if(!ICipher.AES_GCM.equals(cipher.getID()))
            throw new UnsupportedOperationException("Unsupported encryption algorithm: " + cipher.getID());

        byte[] iv = new byte[cipher.getIVSizeInBytes()];

        CryptoFactory.getSecureRandom().nextBytes(iv);

        cipher.setIV(iv);

        byte[] salt = new byte[kdf.getSaltLength()];

        CryptoFactory.getSecureRandom().nextBytes(salt);

        kdf.setSalt(salt);
        kdf.setIterations(KDF_ITERATIONS);
        kdf.setOutputLength(CIPHER_KEY_SIZE);

        char[] decryptedMasterPassword = masterPassword.getDecryptedData();

        byte[] key = kdf.getDerivedKey(decryptedMasterPassword);

        RuntimeSecurity.clear(decryptedMasterPassword);

        cipher.setKey(key);

        out.write(SharedFunctional.MAGIC);
        out.writeShort((short) version);
        out.writeUTF(kdf.getID());
        out.write(kdf.getSalt());
        out.writeInt(kdf.getIterations());

        out.writeUTF(cipher.getID());
        out.writeShort((short) cipher.getKey().length);
        out.write(cipher.getIV());

        final ByteArrayOutputStream baos = new ByteArrayOutputStream();

        final DataOutputStream encryptedOutputData = new DataOutputStream(baos);

        encryptedOutputData.writeInt(passes.getPasses().size());

        for(PasswordInfo passwordInfo : passes.getPasses()) {
            int[] passwordType = passwordInfo.getPasswordType();
            byte[] password = passwordInfo.getPassword();
            long[] creationTime = passwordInfo.getCreationTime();
            long[] modificationTime = passwordInfo.getModificationTime();

            SharedFunctional.writeUTFSecured(encryptedOutputData, passwordInfo.getCaption());
            encryptedOutputData.writeByte(passwordType[0]);
            encryptedOutputData.writeInt(password.length);
            encryptedOutputData.write(password);
            encryptedOutputData.writeLong(creationTime[0]);
            encryptedOutputData.writeLong(modificationTime[0]);

            if(version > V_0) {
                SharedFunctional.writeUTFSecured(encryptedOutputData, passwordInfo.getService());
                SharedFunctional.writeUTFSecured(encryptedOutputData, passwordInfo.getLogin());

                if(version > V_1) {
                    boolean[] autogeneratedPassword = passwordInfo.isAutogeneratedPassword();

                    encryptedOutputData.writeBoolean(autogeneratedPassword[0]);

                    RuntimeSecurity.clear(autogeneratedPassword);
                }
            }

            RuntimeSecurity.clear(passwordType);
            RuntimeSecurity.clear(password);
            RuntimeSecurity.clear(creationTime);
            RuntimeSecurity.clear(modificationTime);
        }

        encryptedOutputData.close();

        byte[] plaintext = baos.toByteArray();

        byte[] ciphertext = cipher.encrypt(plaintext);

        RuntimeSecurity.clear(plaintext);
        RuntimeSecurity.clear(key);

        out.writeInt(ciphertext.length);
        out.write(ciphertext);
    }
}