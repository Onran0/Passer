/*
 *     Passer - is a minimalist CLI password manager focused on security, transparency, and full control over your data
 *     Copyright (C) 2026  Onran
 *
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, either version 3 of the License, or
 *     (at your option) any later version.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.github.onran0.passer.io;

import com.github.onran0.passer.core.PasswordInfo;
import com.github.onran0.passer.core.Passes;
import com.github.onran0.passer.crypto.*;
import com.github.onran0.passer.security.RuntimeSecurity;
import com.github.onran0.passer.security.SecuredCharArray;

import static com.github.onran0.passer.core.PasserCore.*;

import java.io.*;
import java.security.GeneralSecurityException;

public final class PASSERWriter {

    private static final int DEFAULT_STORE_VERSION = V_2;

    private static final int CIPHER_KEY_SIZE = 256;

    private final int version;
    private final DataOutputStream out;
    private final ISymmetricCipher cipher;
    private final IKDF kdf;

    public PASSERWriter(
            final OutputStream out,
            final String cipherAlgorithm,
            final String kdfAlgorithm
    ) {
        this(out, cipherAlgorithm, kdfAlgorithm, DEFAULT_STORE_VERSION);
    }

    public PASSERWriter(
            final OutputStream out,
            final String cipherAlgorithm,
            final String kdfAlgorithm,
            final int version
    ) {
        this.out = new DataOutputStream(out);
        this.cipher = CryptoFactory.getSymmetricCipherInstance(cipherAlgorithm);
        this.kdf = CryptoFactory.getKDFInstance(kdfAlgorithm);
        this.version = version;
    }

    public void write(final Passes passes, final SecuredCharArray masterPassword) throws IOException, GeneralSecurityException {
        if(!ICipher.AES_GCM.equals(cipher.getID()))
            throw new UnsupportedOperationException("Unsupported encryption algorithm: " + cipher.getID());

        byte[] iv = new byte[cipher.getIVSizeInBytes()];

        CryptoFactory.getSecureRandom().nextBytes(iv);

        byte[] salt = new byte[kdf.getSaltLength()];

        CryptoFactory.getSecureRandom().nextBytes(salt);

        char[] decryptedMasterPassword = masterPassword.getDecryptedData();

        byte[] key = new byte[CIPHER_KEY_SIZE / 8];

        var params = kdf.getNewParams();

        kdf.getDerivedKey(decryptedMasterPassword, key, salt, params);

        RuntimeSecurity.clear(decryptedMasterPassword);

        out.write(SharedFunctional.MAGIC);
        out.writeShort((short) version);
        out.writeUTF(kdf.getID());
        out.write(salt);
        params.serialize(out);

        RuntimeSecurity.clear(salt);

        out.writeUTF(cipher.getID());
        out.writeShort((short) key.length);
        out.write(iv);

        final ByteArrayOutputStream baos = new ByteArrayOutputStream();

        final DataOutputStream encryptedOutputData = new DataOutputStream(baos);

        encryptedOutputData.writeInt(passes.getPasses().size());

        for(PasswordInfo passwordInfo : passes.getPasses()) {
            int[] passwordType = passwordInfo.getPasswordType();
            byte[] password = passwordInfo.getPassword();
            long[] creationTime = passwordInfo.getCreationTime();
            long[] modificationTime = passwordInfo.getModificationTime();

            SharedFunctional.writeUTFSecured(encryptedOutputData, passwordInfo.getCaption());
            encryptedOutputData.writeByte(passwordType[0]);
            encryptedOutputData.writeInt(password.length);
            encryptedOutputData.write(password);
            encryptedOutputData.writeLong(creationTime[0]);
            encryptedOutputData.writeLong(modificationTime[0]);

            if(version > V_0) {
                SharedFunctional.writeUTFSecured(encryptedOutputData, passwordInfo.getService());
                SharedFunctional.writeUTFSecured(encryptedOutputData, passwordInfo.getLogin());

                if(version > V_1) {
                    boolean[] autogeneratedPassword = passwordInfo.isAutogeneratedPassword();

                    encryptedOutputData.writeBoolean(autogeneratedPassword[0]);

                    RuntimeSecurity.clear(autogeneratedPassword);
                }
            }

            RuntimeSecurity.clear(passwordType);
            RuntimeSecurity.clear(password);
            RuntimeSecurity.clear(creationTime);
            RuntimeSecurity.clear(modificationTime);
        }

        encryptedOutputData.close();

        byte[] plaintext = baos.toByteArray();

        byte[] ciphertext = cipher.encrypt(plaintext, key, iv);

        RuntimeSecurity.clear(plaintext);
        RuntimeSecurity.clear(key);
        RuntimeSecurity.clear(iv);

        out.writeInt(ciphertext.length);
        out.write(ciphertext);
    }
}