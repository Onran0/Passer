package com.github.onran0.passer.io;

import com.github.onran0.passer.core.PasswordInfo;
import com.github.onran0.passer.core.Passes;
import com.github.onran0.passer.crypto.*;
import com.github.onran0.passer.security.RuntimeSecurity;
import com.github.onran0.passer.security.SecuredCharArray;

import static com.github.onran0.passer.core.PasserCore.*;

import java.io.*;
import java.security.GeneralSecurityException;
import java.util.ArrayList;
import java.util.List;

public final class PASSERReader {

    private final DataInputStream in;

    public PASSERReader(InputStream in) {
        this.in = new DataInputStream(in);
    }

    public Passes read(final SecuredCharArray masterPassword) throws IOException, GeneralSecurityException {
        in.readNBytes(SharedFunctional.MAGIC.length);

        final int version = in.readUnsignedShort();

        if(version > V_2)
            throw new UnsupportedOperationException("Unsupported passes file version: " + version);

        final String kdfAlgorithm = in.readUTF();

        final IKDF kdf = CryptoFactory.getKDFInstance(kdfAlgorithm);

        if(kdf == null)
            throw new UnsupportedOperationException("Unsupported KDF algorithm: " + kdfAlgorithm);

        byte[] salt = in.readNBytes(kdf.getSaltLength());

        kdf.setSalt(salt);
        kdf.setIterations(in.readInt());

        final String encryptionAlgorithm = in.readUTF();

        if(!ICipher.AES_GCM.equals(encryptionAlgorithm))
            throw new UnsupportedOperationException("Unsupported encryption algorithm: " + encryptionAlgorithm);

        int keySize = in.readUnsignedShort();

        kdf.setOutputLength(keySize * 8);

        final ISymmetricCipher cipher = CryptoFactory.getSymmetricCipherInstance(encryptionAlgorithm);

        assert cipher != null;

        char[] decryptedMasterPassword = masterPassword.getDecryptedData();

        byte[] key = kdf.getDerivedKey(decryptedMasterPassword);

        RuntimeSecurity.clear(decryptedMasterPassword);

        cipher.setKey(key);
        cipher.setIV(in.readNBytes(cipher.getIVSizeInBytes()));

        final DataInputStream decryptedDataInput = new DataInputStream(new ByteArrayInputStream(
                cipher.decrypt(in.readNBytes(in.readInt()))
        ));

        RuntimeSecurity.clear(key);

        final List<PasswordInfo> passwordInfos = new ArrayList<>();

        int pairsCount = decryptedDataInput.readInt();

        for (int i = 0; i < pairsCount; i++) {
            char[] caption = SharedFunctional.readUTFSecured(decryptedDataInput);

            int[] passwordType = { decryptedDataInput.readUnsignedByte() };
            byte[] password = decryptedDataInput.readNBytes(decryptedDataInput.readInt());
            long[] creationTime = { decryptedDataInput.readLong() };
            long[] modificationTime = { decryptedDataInput.readLong() };

            char[] service;
            char[] login;
            boolean[] autogeneratedPassword;

            if(version > V_0) {
                service = SharedFunctional.readUTFSecured(decryptedDataInput);
                login = SharedFunctional.readUTFSecured(decryptedDataInput);
                autogeneratedPassword = new boolean[] { version > V_1 && decryptedDataInput.readBoolean() };
            } else {
                service = MISSING_PROPERTY_DEFAULT.clone();
                login = MISSING_PROPERTY_DEFAULT.clone();
                autogeneratedPassword = new boolean[] { false };
            }

            passwordInfos.add(new PasswordInfo(
                caption, service, login, autogeneratedPassword, passwordType, password, creationTime, modificationTime
            ));
        }

        return new Passes(passwordInfos);
    }
}