/*
 *     Passer - is a minimalist CLI password manager focused on security, transparency, and full control over your data
 *     Copyright (C) 2026  Onran
 *
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, either version 3 of the License, or
 *     (at your option) any later version.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.github.onran0.passer.cli.commands;

import com.github.onran0.passer.cli.commands.core.NonOptionArgumentsParser;
import com.github.onran0.passer.cli.commands.core.PasswordBasedCommand;
import com.github.onran0.passer.core.PasswordInfo;
import com.github.onran0.passer.core.PasswordType;
import com.github.onran0.passer.security.RuntimeSecurity;

import joptsimple.OptionParser;
import joptsimple.OptionSet;

import java.util.Arrays;
import java.util.HashMap;
import java.util.function.Consumer;

public class ModifyCommand extends PasswordBasedCommand {

    @Override
    protected boolean openedFileRequired() { return true; }

    @Override
    protected void initializeParser(OptionParser parser, NonOptionArgumentsParser arguments) {
        arguments.defineArgument("id", Integer.class, "Password ID", true);

        parser.acceptsAll(Arrays.asList("c", "cap", "caption"), "Caption of password")
                .withRequiredArg()
                .ofType(String.class);

        parser.acceptsAll(Arrays.asList("l", "log", "login"), "Login of password")
                .withRequiredArg()
                .ofType(String.class);

        parser.acceptsAll(Arrays.asList("s", "srv", "service"), "Service of password")
                .withRequiredArg()
                .ofType(String.class);

        parser.acceptsAll(Arrays.asList("p", "pass", "password"), "Specify that you want to change the password manually");

        parser.acceptsAll(Arrays.asList("g", "pgen", "pgenerate"), "Specify that you want to change the password to a newly generated one");
    }

    @Override
    protected void execute(OptionSet options) {
        int id = (Integer) getArgumentsParser().get(0);

        var passes = getCore().getPasses();

        PasswordInfo passwordInfo = passes.getPasses().get(id);

        if(options.has("pgen") || options.has("pass")) {
            boolean[] autogen = { options.has("pgen") };
            int[] type = passwordInfo.getPasswordType();

            if(autogen[0])
                passwordInfo.setPassword(generatePassword(type));
            else {
                char[] password = requestPassword(type[0] == PasswordType.BINARY.getID());

                passwordInfo.setPassword(extractBytesFromInputPassword(password, type));

                RuntimeSecurity.clear(password);
            }

            passwordInfo.setAutogeneratedPassword(autogen);

            RuntimeSecurity.clear(type);
        }

        final var propertiesSetters = new HashMap<String, Consumer<char[]>>();

        propertiesSetters.put("caption", passwordInfo::setCaption);
        propertiesSetters.put("login", passwordInfo::setLogin);
        propertiesSetters.put("service", passwordInfo::setService);


        for(var property : propertiesSetters.keySet()) {
            if(options.has(property)) {
                propertiesSetters.get(property).accept(
                        String.valueOf(
                                options.valueOf(property)
                        ).toCharArray()
                );
            }
        }

        passwordInfo.setModificationTime(new long[] { System.currentTimeMillis() });

        getCore().setUnsaved();
    }
}